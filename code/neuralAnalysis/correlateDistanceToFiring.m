function allNeuronCorrData = correlateDistanceToFiring(birdIDs, params, varargin)
% generates allNeuronCorrData
if nargin < 2 || isempty(params)
    params = defaultParams;
end
params = processArgs(params, varargin{:});

% in this script: try different analysis combining tutor distances and response
% strengths/responses per syllable
%dataDir = ['data' filesep birdID filesep];
if ~iscell(birdIDs), birdIDs = {birdIDs}; end
allNeuronCorrData = struct([]);
for hh = 1:numel(birdIDs) % bird loop
    birdRep = reportOnData(birdIDs{hh}, [], [], 'verbose',false);
    birdData = struct([]);
    for ii = 1:numel(birdRep) % session loop
        thisSession = birdRep(ii).sessionID;
        hasData = all(findInManifest(birdRep(ii).manifest,{'bestDistScore', 'neuronSyllableData'}));
        hasLabelData = all(findInManifest(birdRep(ii).manifest,{'neuronSyllableData', ...
            'intraClusterDists', 'interClusterDists', 'acceptedLabels'}));
        if ~hasData
            %fprintf('No data for session %s, continuing...\n', thisSession);
            continue;
        end
        
        % load the data collected from each neuron/syllable pair
        % generated by writeNeuronStats
        nSData        = loadFromManifest(birdRep(ii).manifest, 'neuronSyllableData');
        % load the labels from clustering
        % generated by clustering folder: DRcluster and browseAndAccept
        % sessionLabels = loadFromManifest(birdRep(ii).manifest, 'acceptedLabels');
        % load the different types of distances
        % generated in compareTutorJuvenile (the first three and 6th), and
        % saveStereotypy (the 4th and 5th).
        % TODO: write down whole dependency tree (eventually)
        distTo.tutor       = loadFromManifest(birdRep(ii).manifest, 'bestDistScore');
        distTo.consensus   = loadFromManifest(birdRep(ii).manifest, 'distToConsensus');
        distTo.central     = loadFromManifest(birdRep(ii).manifest, 'distToCentral');
        distTo.intra       = loadFromManifest(birdRep(ii).manifest, 'intraClusterDists');
        distTo.inter       = loadFromManifest(birdRep(ii).manifest, 'interClusterDists');
        distTo.humanMatch  = loadFromManifest(birdRep(ii).manifest, 'distToHumanMatch');
        
        nNeurons  = size(nSData, 1);
        nClusters = size(nSData, 2)-1; % not the "unlabeled" clusters
        
        % Bonferroni correction for neurons that fire significantly to a
        % given syllable
        correctedP = 0.05/(nNeurons * nClusters);
        nR = floor(sqrt(nClusters));
        nC = ceil(nClusters/nR);
        %%
        sessionData = struct([]);
        fprintf('Reading data for session %s, %d neurons, %d clusters...\n', thisSession, nNeurons, nClusters);
        
        for jj = 1:nNeurons  % neuron loop
            % neuronData is a collection of cluster correlation data for a given neuron
            neuronData = struct([]);
            dPs = fieldnames(distTo);
            
            hf = zeros(1,numel(dPs)); %figure handles
            hasAnyPlot = false(1,numel(dPs)); % whether a plot was created - for titling/init purposes
            
            for kk = 1:nClusters % syllable cluster loop
                thisNeuronEntry = nSData(jj,kk);
                % take out the neuron/syll pair entries for the unlabeled
                % syllable
                if isnan(thisNeuronEntry.syllID)
                    continue;
                end
                
                
                % corrData stores the correlation data between a neuron and a
                % corresponding syllable cluster
                corrData.syllID      = thisNeuronEntry.syllID;
                corrData.isCore      = thisNeuronEntry.isCore;
                corrData.isMUA       = thisNeuronEntry.isMUA;
                corrData.isPlastic   = thisNeuronEntry.isPlastic;
                corrData.nSylls      = numel(thisNeuronEntry.syllIndex);
                % does the neuron respond significantly above/baseline for this
                % cluster?
                corrData.sigResponse = (thisNeuronEntry.p_ttest < correctedP);
                % is the neuron excited or inhibited during this syllable?
                corrData.isExcited   = (thisNeuronEntry.FR_syllable > thisNeuronEntry.FR_baseline);
                
                corrData.avgResponse = thisNeuronEntry.FR_syllable - thisNeuronEntry.FR_baseline;
                corrData.pResponse   = thisNeuronEntry.p_ttest;
                corrData.burstFraction = thisNeuronEntry.burstFraction'; %JMA
                
                
                % if there are no cluster labels for this session, it's missing data...
                for ll = 1:numel(dPs)
                    [corrData.([dPs{ll} 'DistanceR2']) corrData.([dPs{ll} 'Distance_p' ]) ...
                        corrData.([dPs{ll} '_farMeanRS']) corrData.([dPs{ll} '_nearMeanRS']), ...
                        corrData.([dPs{ll} '_farSEMRS' ]) corrData.([dPs{ll} '_nearSEMRS' ]), ...
                        corrData.([dPs{ll} '_farZ' ]) corrData.([dPs{ll} '_nearZ' ]), ...
                        corrData.([dPs{ll} '_farNear_tTestP']), corrData.([dPs{ll} '_farNear_tStat']), ...
                        corrData.([dPs{ll} '_dRSnorm']),corrData.([dPs{ll} '_farCov']),corrData.([dPs{ll} '_nearCov']),...
                        corrData.('RSAll'),corrData.([dPs{ll} '_DistanceAll']),...
                        corrData.('FRSyll'),corrData.('FRBase'),corrData.('burstFraction'),corrData.([dPs{ll} '_farCV']),...
                        corrData.([dPs{ll} '_nearCV'])] = ...
                        deal(NaN);
                end
                
                if hasLabelData
                    % loop through these distance prefixes declared in distTo
                    for ll = 1:numel(dPs)
                        % make sure it's not all missing data
                        if all(isnan(distTo.(dPs{ll})(thisNeuronEntry.syllIndex))),
                            % should be looked into
                            warning('No nonNaN values for distances to %s available for cluster %d', dPs{ll}, thisNeuronEntry.syllID);
                            continue;
                        end
                        %All of the quartile stuff is actually done in
                        %plotNeuronCorrData where we specifiy cluster
                        %quality to include etc.
                        
                        % get correlation of response strength to distance metric
                        [corrData.([dPs{ll} 'DistanceR2']) corrData.([dPs{ll} 'Distance_p'])] = ...
                            neuralCorr(thisNeuronEntry, distTo.(dPs{ll}));
                        
                        % get response strengths and SEMS for syllables that match
                        % top 25% and bottom 25% of distance metric
                        %Actually we need FR and SD not RS so JMA changed
                        %this, calculate quartile stuff in
                        %plotNeuronCorrData
%                         [corrData.([dPs{ll} '_farMeanRS']), corrData.([dPs{ll} '_nearMeanRS']), ...
%                             corrData.([dPs{ll} '_farSEMRS' ]), corrData.([dPs{ll} '_nearSEMRS' ]), nQuartile, ...
%                             corrData.([dPs{ll} '_farNear_tTestP']), corrData.([dPs{ll} '_farNear_tStat'])] = ...
%                             neuralQuartileFR(thisNeuronEntry, distTo.(dPs{ll}));
                        [corrData.([dPs{ll} '_farMeanRS']), corrData.([dPs{ll} '_nearMeanRS']), ...
                            corrData.([dPs{ll} '_farSEMRS' ]), corrData.([dPs{ll} '_nearSEMRS' ]), nQuartile, ...
                            corrData.([dPs{ll} '_farNear_tTestP']), corrData.([dPs{ll} '_farNear_tStat']),...
                            corrData.([dPs{ll} '_farCov']),corrData.([dPs{ll} '_nearCov']),...
                            corrData.([dPs{ll} '_farCV']), corrData.([dPs{ll} '_nearCV'])] = ...
                            neuralQuartileFR(thisNeuronEntry, distTo.(dPs{ll}));
                        
                        RS_syll = thisNeuronEntry.rawRates(1,:); RS_base = thisNeuronEntry.rawRates(2,:);
                        covRS = cov(RS_syll, RS_base); if numel(covRS) > 1, covRS = covRS(2,1); end;
                        %                         SE_syllBaseFiring = sqrt(var(RS_syll) + var(RS_base) - 2 * covRS) / sqrt(sum(corrData.nSylls));
                        %                         corrData.([dPs{ll} '_farZ']) = (corrData.([dPs{ll} '_farMeanRS']) - corrData.avgResponse)/ SE_syllBaseFiring;
                        %                         corrData.([dPs{ll} '_nearZ']) = (corrData.([dPs{ll} '_nearMeanRS']) - corrData.avgResponse)/ SE_syllBaseFiring;
                        %JMA changed from this because not the z-score I wanted, rather z-score of
                        %near/far from baseline
                        farVar = sqrt(corrData.([dPs{ll} '_farSEMRS']) + var(RS_base) - 2* corrData.([dPs{ll} '_farCov'])); %JMA added
                        nearVar = sqrt(corrData.([dPs{ll} '_nearSEMRS']) + var(RS_base) - 2* corrData.([dPs{ll} '_nearCov'])); %JMA added
                        corrData.([dPs{ll} '_farZ']) =  ((corrData.([dPs{ll} '_farMeanRS'])  - mean(RS_base))* sqrt(nQuartile(1)))/ farVar; %JMA added
                        corrData.([dPs{ll} '_nearZ']) = ((corrData.([dPs{ll} '_nearMeanRS']) - mean(RS_base))* sqrt(nQuartile(1)))/ nearVar; %JMA added
                        
                        %                        dRS = corrData.([dPs{ll} '_nearMeanRS']) - corrData.([dPs{ll} '_farMeanRS']);
                        corrData.([dPs{ll} '_dRSnorm']) = corrData.([dPs{ll} '_nearZ']) - corrData.([dPs{ll} '_farZ']);
                        %corrData.([dPs{ll} '_dRSnorm']) =
                        %sqrt(sum(nQuartile)) * dRS/sqrt(var(RS_syll) + var(RS_base) - 2 * covRS);
                        corrData.RSAll = RS_syll - RS_base; %JMA added
                        corrData.FRSyll = RS_syll; %JMA added
                        corrData.FRBase = RS_base; %JMA added
                        corrData.([dPs{ll} '_DistanceAll']) = (distTo.(dPs{ll})(thisNeuronEntry.syllIndex));%JMA added

                        
                        %                         if params.plot && corrData.sigResponse %JMA
                        %                         removed .sigResponse and put corrData.isMUA == 0
                        if params.plot & corrData.isMUA == 0
                            if hasAnyPlot(ll)
                                figure(hf(ll)) %<- figure for the distance metric
                            else
                                hf(ll) = figure;
                            end
                            
                            %                             subplot(nR, nC, kk); %<- subplot for the syllable number --this doesn't really work out --JMA
                            neuralCorrPlot(thisNeuronEntry, distTo.(dPs{ll}));
                            ylabel(sprintf('%s distance', dPs{ll}));
                            xlabel(sprintf('RS, \\DeltaRS = %0.2f, \\DeltaRS_n = %0.2f', (corrData.([dPs{ll} '_farMeanRS'])- corrData.([dPs{ll} '_nearMeanRS'])), corrData.([dPs{ll} '_dRSnorm']))); %JMA changed DeltaRS value from dRS which wasn't defined
                            
                            %                             corrData.([dPs{ll} '_RSAll']) = RS_syll - RS_base; %JMA added
                            %                             corrData.([dPs{ll} '_FRSyll']) = RS_syll; %JMA added
                            %                             corrData.([dPs{ll} 'FRBase']) = RS_base; %JMA added
                            %                             corrData.([dPs{ll} '_DistanceAll']) = (distTo.(dPs{ll})(thisNeuronEntry.syllIndex));%JMA added
                            
                            % get/plot the low and high quartile values
                            iqDists = prctile(distTo.(dPs{ll})(thisNeuronEntry.syllIndex), [25 75]);
                            hold on; plot(xlim, iqDists([1 1]), 'b--', xlim, iqDists([2 2]), 'g--'); hold off;
                            
                            title(sprintf('session %s, neur %d, clust %d', ...
                                thisSession, jj, thisNeuronEntry.syllID),'Interpreter','none');
                            hasAnyPlot(ll) = true;
                        end
                    end
                else
                    fprintf('Data missing for session %s, neuron %d, cluster %d...\n',...
                        thisSession, jj, thisNeuronEntry.syllID);
                end
                % add more information about the cluster here?
                neuronData = [neuronData; corrData];
                clear corrData;
            end % end cluster loop
            % add more information about the unit/neuron here
            fprintf('Finished compiling neuron %d for this session %s...\n', jj, thisSession);
            [neuronData.unitNum] = deal(jj);
            sessionData = [sessionData; neuronData];
            
            for ll = 1:numel(dPs)
                if hasAnyPlot(ll)
                    figure(hf(ll))
                    set(gcf,'Units','normalized','Position',[0 0 1 1]);
                    
                    figDir = 'figures/distanceCorrelations/';
                    fileName = [figDir thisSession '-neuron-' num2str(jj) '-' dPs{ll} '.jpg'];
                    %fprintf('Saving figure %s...\n',fileName);
                    saveCurrFigure(fileName);
                    close;
                end
            end
        end % end neuron loop
        fprintf('Finished compiling for this session %s...\n', thisSession);
        [sessionData.sessionID] = deal(thisSession);
        birdData = [birdData; sessionData];
        % add more information about the session here
    end % end session loop
    fprintf('Finished compiling for this bird %s...\n', birdIDs{hh});
    [sessionData.birdID] = deal(birdIDs{hh});
    allNeuronCorrData = [allNeuronCorrData; birdData];
end % end bird loop

save('data/allNeuronCorrelations.mat', 'allNeuronCorrData');
end

function neuralCorrPlot(neuronEntry, dist)
% can't match the NaN/everything else cluster
xxdat = -diff(neuronEntry.rawRates,1,1); % response strengths
yydat = dist(neuronEntry.syllIndex);
if size(xxdat,2) > 1, xxdat = xxdat'; end;
if size(yydat,2) > 1, yydat = yydat'; end;
if numel(yydat) == 1
    linfit = NaN(1,2);
    fitStats = NaN(1,3);
else
    [linfit, ~,~,~, fitStats] = regress(yydat, [ones(numel(xxdat),1) xxdat]);
end
plot(xxdat, yydat, 'k.', 'HandleVisibility', 'off');
hold on;
plot(xxdat, linfit(1) + xxdat * linfit(2), '--','Color',[1 0 0]);
legend(sprintf('r^2 = %0.3g, F = %0.3g, p = %0.3g\n',...
   fitStats(1), fitStats(2),fitStats(3)));
xlabel('Response Strength'); ylabel('Matched distance');
end

% load matchfile
%{
    matchFile = [dataDir 'matchToTutor-age' num2str(getAgeOfSession(thisSession)) '.mat'];
    if exist(matchFile, 'file') == 2
        load(matchFile, 'typeMatch'); % this is generated by assignClusterToTutor
        %% distance just to matched tutor syllable
        distToAllSylls = loadFromManifest(birdRep(ii).manifest,'distToTutor');
        typeMatchIndex = cellfun(@(x) x - 'a' + 1, typeMatch);
        for jj = 1:nNeurons
            figure('Name',[thisSession ' - tutor distance']);
            for kk = 1:nClusters
                % pair of neuron and cluster
                thisPair = nSData(jj,kk);
                
                % only significant neurons
                if thisPair.p_ttest >= correctedP
                    continue;
                end
                % can't match the NaN/everything else cluster
                if isnan(thisPair.syllID)
                    continue;
                end
                xxdat = diff(thisPair.rawRates,1); % response strengths
                yydat = distToAllSylls(typeMatchIndex(kk), thisPair.syllIndex);
                
                % get the linear regression
                subplot(nR, nC, kk);
                if numel(yydat) == 1
                    linfit = NaN(1,2);
                    fitStats = NaN(1,3);
                else
                    [linfit, ~,~,~, fitStats] = regress(yydat', [ones(numel(xxdat),1) xxdat']);
                end
                plot(xxdat, yydat, 'k.', 'HandleVisibility', 'off');
                hold on;
                plot(xxdat, linfit(1) + xxdat * linfit(2), '--','Color',[1 0 0]);
                legend(sprintf('r^2 = %0.3g, F = %0.3g, p = %0.3g\n',...
                    fitStats(1), fitStats(2),fitStats(3)));
                xlabel('Response Strength'); ylabel('Matched distance');
                title(sprintf('session %s, neuron %d, cluster %d', thisSession, jj, thisPair.syllID),'Interpreter','none');
            end
        end
    else
        % there's no match file
        fprintf('No match file for bird %s found...\n', birdID);
    end
%}


function [corr_val, corr_p] = neuralCorr(neuronEntry, distanceMetric)
% neuronEntry describes the firing rates of neuron and matching cluster
% distanceMetric is the distances of some type for all
% syllables within a session

% only significant neurons
xxdat = -diff(neuronEntry.rawRates,1); % response strengths just as differences
if size(xxdat,2) > 1, xxdat = xxdat'; end;
yydat = distanceMetric(neuronEntry.syllIndex);
if size(yydat,2) > 1, yydat = yydat'; end;

% get the linear regression

% can't regress if only one syllable exists, or all the syllables have the
% saem response strengths
if numel(yydat) == 1 || all(xxdat == xxdat(1))
    corr_val = 0; corr_p = 1; return;
else
    % convert rank-deficiency to an error
    s = warning('error','stats:regress:RankDefDesignMat');
    try
        [linfit, ~,~,~, fitStats] = regress(yydat, [ones(numel(xxdat),1) xxdat]);
    catch err
        if strcmp(err.identifier,'stats:regress:RankDefDesignMat');
            keyboard
        else
            rethrow(err);
        end
    end
    warning(s)
    corr_val = fitStats(1);
    corr_p = fitStats(3);
    % F_value is fitStats(2)
end
end

function [fq_meanRS, nq_meanRS, fq_SEMRS, nq_SEMRS, nQuartile, pVal, tVal,fcovar, ncovar, farCV, nearCV] = neuralQuartileFR(neuronEntry, distanceMetric)
% neuronEntry describes the firing rates of neuron and matching cluster
% distanceMetric is the distances of some type for all
% syllables within a session

%JMA changed to get FRs not RS to generate z-scores
% fq describes the far quartile of a syllable cluster (relative to
% some distance)
% nq describes the near quartile

% response strengths are differences between the firing between events (first row)
% and matched baselines (second row)
% RSs = -diff(neuronEntry.rawRates,1);
RSs = neuronEntry.rawRates(1,:);
Bas = neuronEntry.rawRates(2,:); %JMA added
% distances are selected only for the syllable cluster this neuronEntry
% refers to
dists = distanceMetric(neuronEntry.syllIndex);

% only one syllable? this shouldn't happen

if numel(distanceMetric) == 1,
    fq_meanRS=RSs; nq_meanRS=RSs; fq_SEMRS=NaN; nq_SEMRS=NaN; nQuartile = [0 0]; return;
end

% get the low and high quartile values
iqDists = prctile(dists, [25 75]);
near_quartileRS = RSs(dists < iqDists(1)); nQuartile(1) = numel(near_quartileRS);
far_quartileRS  = RSs(dists > iqDists(2)); nQuartile(2) = numel( far_quartileRS);
% nq_meanRS = mean(near_quartileRS); nq_SEMRS = std(near_quartileRS) / sqrt(nQuartile(1) - 1);
% fq_meanRS = mean( far_quartileRS); fq_SEMRS = std( far_quartileRS) / sqrt(nQuartile(2) - 1);
nq_meanRS = mean(near_quartileRS); nq_SEMRS = var(near_quartileRS); %JMA changed to get variance to generate z-score
fq_meanRS = mean( far_quartileRS); fq_SEMRS = var( far_quartileRS);
[~, pVal, ~, tValStruct] = ttest2(near_quartileRS, far_quartileRS);
tVal = tValStruct.tstat;
fcovar = cov(RSs(dists > iqDists(2)),Bas(dists > iqDists(2)));if numel(fcovar) > 1, fcovar = fcovar(2,1); end; %JMA added
ncovar = cov(RSs(dists < iqDists(1)),Bas(dists < iqDists(1)));if numel(ncovar) > 1, ncovar = ncovar(2,1); end; %JMA added
farCV = std(far_quartileRS)/fq_meanRS; %JMA added
nearCV = std(near_quartileRS)/fq_meanRS; %JMA added
end