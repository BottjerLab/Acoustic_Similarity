function [syllData, justNeuronData, CoreAFPlas, ShellAFPlas, CoreAFSub, ShellAFSub] = activityFraction(birdIDs, params, varargin)
% JMA 1/13/15 adapted from JS correlateDistanceToFiring to get activity fraction
%birdIDs ={'Db113','Dg138','Gy217','Gy242','Lb189','Lb277','R204','R247','R288','Y231'};
if nargin < 2 || isempty(params)
    params = defaultParams;
end
params = processArgs(params, varargin{:});


%dataDir = ['data' filesep birdID filesep];
if ~iscell(birdIDs), birdIDs = {birdIDs}; end
syllData = struct([]);
justNeuronData = struct([]);
for hh = 1:numel(birdIDs) % bird loop
    birdRep = reportOnData(birdIDs{hh}, [], [], 'verbose',false);
    birdData = struct([]);
    for ii = 1:numel(birdRep) % session loop
        thisSession = birdRep(ii).sessionID;
        hasData = all(findInManifest(birdRep(ii).manifest,{'neuronSyllableData'}));
        hasLabelData = all(findInManifest(birdRep(ii).manifest,{'neuronSyllableData', ...
            'acceptedLabels'}));
        if ~hasData
            %fprintf('No data for session %s, continuing...\n', thisSession);
            continue;
        end
        
        % load the data collected from each neuron/syllable pair
        % generated by writeNeuronStats
        nSData = loadFromManifest(birdRep(ii).manifest, 'neuronSyllableData');
        
        % load the labels from clustering
        % generated by clustering folder: DRcluster and browseAndAccept
        sessionLabels = loadFromManifest(birdRep(ii).manifest, 'acceptedLabels');
        
        nNeurons  = size(nSData, 1);
        nClusters = size(nSData, 2)-1; % not the "unlabeled" clusters
        
        % Bonferroni correction for neurons that fire significantly to a
        % given syllable
        %         correctedP = 0.05/(nNeurons * nClusters);
        %         nR = floor(sqrt(nClusters));
        %         nC = ceil(nClusters/nR);
        %%
        sessionData = struct([]);
        fprintf('Reading data for session %s, %d neurons, %d clusters...\n', thisSession, nNeurons, nClusters);
        
        for jj = 1:nNeurons  % neuron loop
            % neuronData is a collection of cluster correlation data for a given neuron
            neuronData = struct([]);
            for kk=1:nClusters %loop to shuffle syllable IDs
                thisNeuronEntry = nSData(jj,kk);
                if isempty(thisNeuronEntry.rawRates)
                    continue
                end
                rates = thisNeuronEntry.rawRates;
                syllRates = rates(1,:)';
                allSyllRates{kk} = syllRates;
            end
            combSyllRates = vertcat(allSyllRates{:}); %all combined syllable responses
            for ll = 1:length(combSyllRates)
                combSyllRates(ll,2) = randi([1 nClusters],1,1); %randomly assign syllable cluster
            end
            for kk = 1:nClusters
                isThisCluster = combSyllRates(:,2) ==kk;
                thisCluster = combSyllRates(isThisCluster,1);
                shuffledData(jj,kk) = mean(thisCluster); %get average firing rate
            end

            for kk = 1:nClusters % syllable cluster loop
                thisNeuronEntry = nSData(jj,kk);
                % take out the neuron/syll pair entries for the unlabeled
                % syllable
                if isnan(thisNeuronEntry.syllID)
                    continue
                end
                
                % AFData stores the data between a neuron and a corresponding syllable cluster
                AFData.syllID      = thisNeuronEntry.syllID;
                AFData.isCore      = thisNeuronEntry.isCore;
                AFData.isMUA       = thisNeuronEntry.isMUA;
                AFData.isPlastic   = thisNeuronEntry.isPlastic;
                AFData.nSylls      = numel(thisNeuronEntry.syllIndex);
                % does the neuron respond significantly above/baseline for this
                % cluster?
                AFData.sigResponse = (thisNeuronEntry.p_ttest < 0.05); %AFData.sigResponse = (thisNeuronEntry.p_ttest < correctedP);
                %                 % is the neuron excited or inhibited during this syllable?
                AFData.isExcited   = (thisNeuronEntry.FR_syllable > thisNeuronEntry.FR_baseline);
                
                AFData.avgResponse = thisNeuronEntry.FR_syllable; % AFData.avgResponse = thisNeuronEntry.FR_syllable - thisNeuronEntry.FR_baseline;
                AFData.pResponse   = thisNeuronEntry.p_ttest;
                AFData.shuffledResponse = shuffledData(jj,kk); %response to shuffled syllables
                % if there are no cluster labels for this session, it's missing data...
                
                if ~hasLabelData
                    fprintf('Data missing for session %s, neuron %d, cluster %d...\n',...
                        thisSession, jj, thisNeuronEntry.syllID);
                end
                % add more information about the cluster here?
                neuronData = [neuronData; AFData];
                clear AFData;
            end % end cluster loop
            %% calculate activity fraction
            if ~isempty(neuronData)
                totalCluster = max([neuronData.syllID]); %number of cluster types
                r1 = sum([neuronData.avgResponse]);
                r2 = ([neuronData.avgResponse].^2)/totalCluster;
                firstSum = (r1/totalCluster)^2;
                secondSum = sum(r2);
                aFraction = (1- (firstSum/secondSum))/(1 - 1/totalCluster); %Vinje & Gallant 2000, Meliza & Margoliash 2012
                [neuronData.activityFrac] = deal(aFraction);
            end
                        %% calculate activity fraction for shuffled syllable IDs
            if ~isempty(neuronData)
                totalCluster = max([neuronData.syllID]); %number of cluster types
                r1 = sum([neuronData.shuffledResponse]);
                r2 = ([neuronData.shuffledResponse].^2)/totalCluster;
                firstSum = (r1/totalCluster)^2;
                secondSum = sum(r2);
                shuffleFraction = (1- (firstSum/secondSum))/(1 - 1/totalCluster); %Vinje & Gallant 2000, Meliza & Margoliash 2012
                [neuronData.shuffledActivityFrac] = deal(shuffleFraction);
            end
            
            
            fprintf('Finished compiling neuron %d for this session %s...\n', jj, thisSession);
            if ~isempty (neuronData)
                [neuronData.unitNum] = deal(jj);
                sessionData = [sessionData; neuronData];
                
                sparseness.isCore = thisNeuronEntry.isCore;
                sparseness.isMUA = thisNeuronEntry.isMUA;
                sparseness.isPlastic = thisNeuronEntry.isPlastic;
                sparseness.fraction = aFraction;
                sparseness.shuffleFraction = shuffleFraction;
                isExc = [neuronData.isExcited] == 1 & [neuronData.sigResponse] == 1;
                if sum(isExc)>0
                    sparseness.isSigExcited = 1;
                else
                    sparseness.isSigExcited = 0;
                end
                justNeuronData = [justNeuronData;sparseness];
            end
            
        end % end neuron loop
        fprintf('Finished compiling for this session %s...\n', thisSession);
        if ~isempty(sessionData)
        [sessionData.sessionID] = deal(thisSession);
        birdData = [birdData; sessionData];
        end
        % add more information about the session here
    end % end session loop
    fprintf('Finished compiling for this bird %s...\n', birdIDs{hh});
    [sessionData.birdID] = deal(birdIDs{hh});
    syllData = [syllData; birdData];
end % end bird loop

%should this be only neurons that significantly respond to singing, or respond significantly (excited) to a syllable?
isCore =   [justNeuronData.isCore];
isMUA =    [justNeuronData.isMUA];
isPlas =   [justNeuronData.isPlastic];
isSigExc = [justNeuronData.isSigExcited];

isCoreSUAPlas =  isCore & ~isMUA & isPlas & isSigExc;
isShellSUAPlas = ~isCore & ~isMUA & isPlas & isSigExc;
CoreAFPlas =  [justNeuronData(isCoreSUAPlas).fraction]';
ShellAFPlas = [justNeuronData(isShellSUAPlas).fraction]';

isCoreSUASub =  isCore & ~isMUA & ~isPlas & isSigExc;
isShellSUASub = ~isCore & ~isMUA & ~isPlas & isSigExc;
CoreAFSub =  [justNeuronData(isCoreSUASub).fraction]';
ShellAFSub = [justNeuronData(isShellSUASub).fraction]';
end