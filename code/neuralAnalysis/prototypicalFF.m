function [justNeuronData, pairedNeuronData] = prototypicalFF(birdIDs, params, varargin)
% JMA 3/04/17 combined stuff from allBirdsFeatureAnalysis and correlateDistanceToFiring to get syllables
% with most and least prototypical FF to compare with Doupe and Brainard
% papers
%birdIDs ={'Db113','Dg138','Gy217','Gy242','Lb189','Lb277','R204','R247','R288','Y231'};

if nargin < 2 || isempty(params)
    params = defaultParams;
end
params = processArgs(params, varargin{:});
if ~iscell(birdIDs), birdIDs = {birdIDs}; end
justNeuronData = struct([]);

%% Adding in cluster quality cutoff
load('data/allNeuronCorrelations.mat');
sessionIDs = {allNeuronCorrData.sessionID};
birdIDss = strtok(sessionIDs, '_');
[uSessions, ~, rIdxSession] = unique(sessionIDs);  % index through ages can go back to sessions
uAges = getAgeOfSession(uSessions);
sessionAges = zeros(size(sessionIDs));
for ii = 1:numel(uAges)
    sessionAges(rIdxSession == ii) = uAges(ii);
end
[sessionObjQ, allObj ]  = getClusterQuality(birdIDss, sessionAges, [allNeuronCorrData.syllID], true);
foo = num2cell(sessionObjQ); [allNeuronCorrData.clusterObjQ] = foo{:};

%%
protoFFInfoBird = struct([]);
for hh = 1:numel(birdIDs) % bird loop
    birdRep = reportOnData(birdIDs{hh}, [], [], 'verbose',false); %AF
    birdDataDir = ['data' filesep birdIDs{hh} filesep];%Feature
    load([birdDataDir 'allSpecs-' birdIDs{hh} '.mat']);%Feature
    
    %% censor features:
    censorList = {'harmonicPitch', 'aperiodicity'}; % JMA added aperiodicity because we didn't do this for clustering?
    
    for jj = 1:numel(censorList)
        censorItem = censorList{jj};
        len = length(censorItem);
        fn = fieldnames(featureTable);
        toRemove = strncmp(censorItem, fn, len);
        featureTable = rmfield(featureTable, fn(toRemove));
    end
    for ii = 1:numel(birdRep) % session loop
        thisSession = birdRep(ii).sessionID; %AF
        thisSessinData = strcmp(thisSession,sessionIDs);
        thisNeuronCorrData = allNeuronCorrData(thisSessinData);
        hasData = all(findInManifest(birdRep(ii).manifest,{'neuronSyllableData'})); %AF
%         hasLabelData = all(findInManifest(birdRep(ii).manifest,{'neuronSyllableData', ...%AF
%             'acceptedLabels'}));
        if ~hasData
            %fprintf('No data for session %s, continuing...\n', thisSession);
            continue;
        end
               
        % load the data collected from each neuron/syllable pair
        % generated by writeNeuronStats
        nSData = loadFromManifest(birdRep(ii).manifest, 'neuronSyllableData'); %AF
     
        % load the labels from clustering
        % generated by clustering folder: DRcluster and browseAndAccept
        sessionLabels = loadFromManifest(birdRep(ii).manifest, 'acceptedLabels'); %AF
              
        nNeurons  = size(nSData, 1); %AF
        nClusters = size(nSData, 2)-1; % not the "unlabeled" clusters
        
        sessManifest = birdRep(ii).manifest; %Feature
      
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % load the songstruct with only metadata, 'metaStruct' - %Feature
        blankedSongStruct = loadFromManifest(sessManifest,'metaStruct');
        
        if isempty(blankedSongStruct)
            fprintf('Missing song metadata, skipping session %s.\n',thisSession);
            continue;
        end
%         
        % set up bird-specific parameters
%         params = processArgs(defaultParams, 'fs', 1/blankedSongStruct.interval);
%         
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % ANALYSIS: run for each section AND extract the
        % necessary summary statistics
        fprintf('Analyzing session %s/%s...\n', birdIDs{hh}, thisSession);
        
        matchingFileA = [birdDataDir thisSession '.mat'];
        matchingFileB = [birdDataDir filesep thisSession '.mat'];
        
        matchesFile = strcmpi(matchingFileA, {DRsylls.file}) | strcmpi(matchingFileB, {DRsylls.file});
        
        matchSylls = DRsylls(matchesFile);
        matchFeatures = featureTable(matchesFile);
%         matchSpectra = spectra(matchesFile);
        matchSylls = addPrePost(matchSylls,[],'preroll', 50, 'postroll', 0);%adding in time lag for premotor-ness
        [matchSylls.type] = deal('syllable');
        %%
        fprintf('Reading data for session %s, %d neurons, %d clusters...\n', thisSession, nNeurons, nClusters);
        
        for jj = 1:nNeurons  % neuron loop
            allSyllRates = [];
            allSyllIndex = [];
            allClusterID = [];
            allClusterQ = [];
            combSyllData = [];
            freqData = zeros(length(sessionLabels),2);
            for kk=1:nClusters %loop to compile responses and syllable IDs
                ClusterID=[];
                ClusterQ = [];
                thisNeuronEntry = nSData(jj,kk);
                if isempty(thisNeuronEntry.rawRates)
                    continue
                end
                rates = thisNeuronEntry.rawRates;
                syllRates = rates(1,:)';
                allSyllRates{kk} = syllRates;
                allSyllIndex{kk} = thisNeuronEntry.syllIndex;
                ClusterID(1:length(syllRates),1) = thisNeuronEntry.syllID;
                allClusterID{kk} = ClusterID;
                theseSyllIDs = [thisNeuronCorrData.syllID];
                thisClusterQIndex = [];
                for mm = 1:length(theseSyllIDs)
                    if thisNeuronEntry.syllID == theseSyllIDs(mm)
                        thisClusterQIndex(mm) = 1;
                    else
                        thisClusterQIndex(mm) = 0;
                    end
                end
                thisClusterQIndex = logical(thisClusterQIndex);
                thisClusterQ = thisNeuronCorrData(thisClusterQIndex).clusterObjQ;
                ClusterQ(1:length(syllRates),1) = thisClusterQ(1);
                allClusterQ{kk} = ClusterQ;                
            end
            if isempty(allSyllRates)
                continue
            end
            combSyllData(:,1) = vertcat(allSyllRates{:}); %all combined syllable responses
            combSyllData(:,2) = vertcat(allSyllIndex{:}); %all combined syllable indexes
            combSyllData(:,3) = vertcat(allClusterID{:}); %all combined syllable IDs
            combSyllData(:,4) = vertcat(allClusterQ{:}); %all combined syllable quality
            
            fprintf('Finished compiling neuron %d for this session %s...\n', jj, thisSession);
            
            sparseness.isCore = thisNeuronEntry.isCore;
            sparseness.isMUA = thisNeuronEntry.isMUA;
            sparseness.isPlastic = thisNeuronEntry.isPlastic;
            sparseness.session = thisSession;
            sparseness.birdID = birdIDs{hh};
            sparseness.birdAge = matchSylls(1).age;
            sparseness.syllData = combSyllData;
            freqData(:,1) = [matchFeatures.fundamentalFreq_nanmean]'; %FF to compare to Brainard and Doupe papers
            freqData(:,2) = sessionLabels;
            [~,I] = sort(freqData(:,2));
            freqData =freqData(I,:);
            sparseness.featureInfo = freqData;
            justNeuronData = [justNeuronData;sparseness];
            
        end % end neuron loop
        fprintf('Finished compiling for this session %s...\n', thisSession);
        % add more information about the session here
    end % end session loop
    thisBirdNow = strcmp(birdIDs{hh},{justNeuronData.birdID});
    birdNow = justNeuronData(thisBirdNow);
    thisBirdAges = [birdNow.birdAge];
    [uAges, ~, rIdxAges] = unique(thisBirdAges);
    FFinfo = struct([]);
    thisAgeFFInfo= [];
    protoFFInfoAge = struct([]);
    for oo = 1:length(uAges)
        ageFeature = birdNow(rIdxAges == oo);
        for pp = 1:size(ageFeature,2)
            FFinfo{pp} = ageFeature(pp).featureInfo;
            FFInfoSess{pp} = ageFeature(pp).session;
        end
        [uSession, ~, rIdxSessions] = unique(FFInfoSess);
        thisSessionFFInfo = struct([]);
        for qq = 1:length(uSession)
            isUSession = FFinfo(rIdxSessions == qq);
            thisSessionFFInfo{qq} = isUSession{1,1};
        end
        if length(thisSessionFFInfo)==1
            thisAgeFFInfo= thisSessionFFInfo{1,1};
        else
            thisAgeFFInfo = vertcat(thisSessionFFInfo{:});
        end
        [uCluster, ~, rIdxCluster] = unique(thisAgeFFInfo(:,2));
        protoFFInfo = struct([]);
        for rr = 1:length(uCluster)
            if isnan(uCluster(rr)) %remove NaN clusters
                continue
            else
            thisCluster  = thisAgeFFInfo(rIdxCluster == rr);
            clusterMeanFF = mean(thisCluster(:,1));
            clusterMeanPair.birdID = birdIDs{hh};
            clusterMeanPair.age = uAges(oo);
            clusterMeanPair.syllID = uCluster(rr);
            clusterMeanPair.MeanFF = clusterMeanFF;
            protoFFInfo{rr} = clusterMeanPair;
            end
        end
        protoFFInfoAge{oo} = vertcat(protoFFInfo{:});
    end
       protoFFInfoBird{hh} = vertcat(protoFFInfoAge{:});
    
    
    
    
    fprintf('Finished compiling for this bird %s...\n', birdIDs{hh});
end % end bird loop
protoFFInfoAll = vertcat(protoFFInfoBird{:});

%% Get the FRs and CV of FR during production of syllables with most and least prototypical FF

isEnoughSyll = zeros(1,length(justNeuronData));
for ss = 1:length(justNeuronData)
    isthisBird = strcmp(justNeuronData(ss).birdID,{protoFFInfoAll.birdID});
    isthisAge = [protoFFInfoAll.age] == justNeuronData(ss).birdAge;
    theseSyll = isthisBird & isthisAge;
    toRemove = justNeuronData(ss).featureInfo;
    removing = zeros(1, length(justNeuronData(ss).featureInfo));
    for vv = 1:length(justNeuronData(ss).featureInfo)
        if isnan(toRemove(vv,2))
            removing(vv) = 0;
        else
            removing(vv) = 1;
        end
    end
    removing = logical(removing);
    toRemove = toRemove(removing,:);
    justNeuronData(ss).featureInfo = toRemove;
    currFeatureInfo = justNeuronData(ss).featureInfo;
    currSyllInfo = justNeuronData(ss).syllData;
    sRemoving = zeros(1,length(justNeuronData(ss).featureInfo));
    aveFF = zeros(1,length(justNeuronData(ss).featureInfo));
    for tt = 1:length(justNeuronData(ss).featureInfo)
        currID = currFeatureInfo(tt,2);
        thisSyll = [protoFFInfoAll(theseSyll).syllID]== currID;
        if sum(thisSyll)==0
            aveFF(tt) = 0;
            sRemoving(tt) = 0;
        else
            sRemoving(tt) = 1;
            these = protoFFInfoAll(theseSyll);
            aveFF(tt) = these(thisSyll).MeanFF;
        end
        
    end
    sRemoving = logical(sRemoving);
    justNeuronData(ss).meanFF = aveFF(sRemoving);
    fDR = justNeuronData(ss).featureInfo;
    justNeuronData(ss).featureInfo = fDR(sRemoving,:);
    if isempty(justNeuronData(ss).meanFF)
        continue
    end
    
    qRemove = zeros(1,length(justNeuronData(ss).featureInfo));
    for ww = 1:length(justNeuronData(ss).featureInfo)
        currQ = currSyllInfo(ww,4);
        if currQ >= 0.8 %only good quality clusters
            qRemove(ww) = 0;
        else
            qRemove(ww) = 1;
        end
    end
    qRemove = logical(qRemove);
    FFI = justNeuronData(ss).featureInfo;
    FFI = FFI(qRemove,:);
    FF = FFI(:,1);
    qMeanFF = justNeuronData(ss).meanFF;
    qMeanFF = qMeanFF(qRemove);
    absDiff = abs(qMeanFF - FF');
    justNeuronData(ss).absDiff = absDiff;
    rates = currSyllInfo(:,1);
    rates = rates(qRemove);
    diffInFF = justNeuronData(ss).absDiff;
    iqDiff = prctile(diffInFF, [25 75]);
    low_FR = rates(diffInFF <= iqDiff(1)); %most prototypical FF across all syllable types
    high_FR  = rates(diffInFF >= iqDiff(2)); %least prototypical FF across all syllable types
    low_meanFR = mean(low_FR);
    low_CV = std(low_FR)/low_meanFR;
    high_meanFR = mean(high_FR);
    high_CV = std(high_FR)/high_meanFR;
    justNeuronData(ss).lowFR = low_meanFR;
    justNeuronData(ss).highFR = high_meanFR;
    justNeuronData(ss).lowCV = low_CV;
    justNeuronData(ss).highCV = high_CV;
    if length(rates) > 39;%Require minimum of 40 total identified syllables to match what I did for tutor and intra similarity
        isEnoughSyll(ss) = 1;
    else
        isEnoughSyll(ss) = 0;
    end    
end
isEnoughSyll = logical(isEnoughSyll);
pairedNeuronData = justNeuronData;
justNeuronData = justNeuronData(isEnoughSyll);
nRemove = zeros(1,length(pairedNeuronData));
for xx = 1:length(pairedNeuronData)
    getClusters = pairedNeuronData(xx).featureInfo(:,2);
    getDiff = pairedNeuronData(xx).absDiff;
    forRates = pairedNeuronData(xx).syllData;
    rates = forRates(:,1);
    qRemove = zeros(1,length(getClusters));
    for ww = 1:length(getClusters)
        currQ = forRates(ww,4);
        if currQ >= 0.8 %only good quality clusters
            qRemove(ww) = 0;
        else
            qRemove(ww) = 1;
        end
    end
    qRemove = logical(qRemove);
    rates = rates(qRemove);
    getClusters = getClusters(qRemove);
    [uCluster, ~, rIdxCluster] = unique(getClusters);
    pairedData = [];
    isEnoughSyll = zeros(1,length(uCluster));
    for rr = 1:length(uCluster)
        currentCluster = rIdxCluster ==rr;
        eachRates = rates(currentCluster);
        eachDiff = getDiff(currentCluster);
        iqDiff = prctile(eachDiff, [25 75]);
        low_FR = eachRates(eachDiff <= iqDiff(1)); %most prototypical FF across each syllable types
        high_FR  = eachRates(eachDiff >= iqDiff(2)); %least prototypical FF across each syllable types
        low_meanFR = mean(low_FR);
        low_CV = std(low_FR)/low_meanFR;
        high_meanFR = mean(high_FR);
        high_CV = std(high_FR)/high_meanFR;
        pairedData(rr).lowFR = low_meanFR;
        pairedData(rr).highFR = high_meanFR;
        pairedData(rr).lowCV = low_CV;
        pairedData(rr).highCV = high_CV;
        if length(eachRates) > 39;%Require minimum of 40 syllables per cluster
            isEnoughSyll(rr) = 1;
        else
            isEnoughSyll(rr) = 0;
        end
    end
    isEnoughSyll = logical(isEnoughSyll);
    if isempty(pairedData)
        nRemove(xx) = 0;
        pairedNeuronData(xx).lowFR = 0;
        pairedNeuronData(xx).highFR = 0;
        pairedNeuronData(xx).lowCV = 0;
        pairedNeuronData(xx).highCV = 0;
    else
        nRemove(xx) = 1;
        pairedNeuronData(xx).lowFR = pairedData(isEnoughSyll).lowFR;
        pairedNeuronData(xx).highFR = pairedData(isEnoughSyll).highFR;
        pairedNeuronData(xx).lowCV = pairedData(isEnoughSyll).lowCV;
        pairedNeuronData(xx).highCV = pairedData(isEnoughSyll).highCV;
    end
end
nRemove = logical(nRemove);
pairedNeuronData = pairedNeuronData(nRemove);


end